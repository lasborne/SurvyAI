# Generated by SurvyAI
# This script was dynamically generated based on user request
# Generated: 2026-02-15T10:03:53.115386
# 
# Execute this script in ArcGIS Pro's Python Window if needed:
# exec(open(r'C:\Users\UZOR\PycharmProjects\untitled\venv\SurvyAI\scripts\survyai_script_20260215_100353.py').read())

import arcpy, os

excel_path = r"C:\Users\UZOR\PycharmProjects\untitled\venv\SurvyAI\WELL 8 POST DATA.xlsx"
sheet_name = "WELL 8 POST FILL DATA FINAL"
x_field = "Eastings"
y_field = "Northings"
post_z_excel = "post fill"
pre_z_excel = "pre fill"
coord_sys = "Minna / Nigeria Mid Belt"

ws = os.path.dirname(excel_path)
gdb = os.path.join(ws, "fill_volume.gdb")
if not arcpy.Exists(gdb):
    arcpy.management.CreateFileGDB(ws, "fill_volume.gdb")

arcpy.env.workspace = gdb
arcpy.env.overwriteOutput = True

# Import Excel to table
excel_table = os.path.join(gdb, "well8_table")
if arcpy.Exists(excel_table):
    arcpy.management.Delete(excel_table)

arcpy.conversion.ExcelToTable(excel_path, excel_table, sheet_name)

# Discover true field names after Excel import
fields = [f.name for f in arcpy.ListFields(excel_table)]

# Helper to match a logical name ignoring spaces/case/underscores
def match_field(logical_name):
    ln = logical_name.replace(" ", "").replace("_", "").lower()
    for f in fields:
        fn = f.replace(" ", "").replace("_", "").lower()
        if fn == ln:
            return f
    for f in fields:
        fn = f.replace(" ", "").replace("_", "").lower()
        if ln in fn or fn in ln:
            return f
    return None

post_z_field = match_field(post_z_excel) or post_z_excel
pre_z_field = match_field(pre_z_excel) or pre_z_excel
x_field_real = match_field(x_field) or x_field
y_field_real = match_field(y_field) or y_field

print("RESULT_DEBUG_FIELDS:", fields)
print("RESULT_DEBUG_MATCHED:", x_field_real, y_field_real, post_z_field, pre_z_field)

# Create point feature class
sr = arcpy.SpatialReference(coord_sys)
points_fc = os.path.join(gdb, "well8_points")
if arcpy.Exists(points_fc):
    arcpy.management.Delete(points_fc)

arcpy.management.CreateFeatureclass(gdb, "well8_points", "POINT", spatial_reference=sr)
arcpy.management.AddField(points_fc, "Chainages", "DOUBLE")
arcpy.management.AddField(points_fc, "PostZ", "DOUBLE")
arcpy.management.AddField(points_fc, "PreZ", "DOUBLE")

with arcpy.da.SearchCursor(excel_table, ["Chainages", x_field_real, y_field_real, post_z_field, pre_z_field]) as sc:
    with arcpy.da.InsertCursor(points_fc, ["Chainages", "PostZ", "PreZ", "SHAPE@XY"]) as ic:
        for ch, x, y, postz, prez in sc:
            try:
                xf = float(str(x).replace(",", ""))
                yf = float(str(y).replace(",", ""))
                pz = float(str(postz)) if postz not in (None, "", " ") else None
                rz = float(str(prez)) if prez not in (None, "", " ") else None
                if pz is None or rz is None:
                    continue
                ic.insertRow((ch, pz, rz, (xf, yf)))
            except Exception:
                continue

# Create IDW rasters for pre and post
cell_size = 5
post_idw = os.path.join(gdb, "post_idw")
pre_idw = os.path.join(gdb, "pre_idw")
for r in [post_idw, pre_idw]:
    if arcpy.Exists(r):
        arcpy.management.Delete(r)

from arcpy.sa import Idw
arcpy.CheckOutExtension("Spatial")
Idw(points_fc, "PostZ", cell_size=cell_size).save(post_idw)
Idw(points_fc, "PreZ", cell_size=cell_size).save(pre_idw)

# Cut/Fill (post minus pre)
fill_raster = os.path.join(gdb, "fill_raster")
if arcpy.Exists(fill_raster):
    arcpy.management.Delete(fill_raster)

arcpy.ddd.CutFill(pre_idw, post_idw, fill_raster)

# Compute volume where there is positive fill only (post > pre)
import numpy as np

r_desc = arcpy.Describe(fill_raster)
csx = r_desc.meanCellWidth
csy = r_desc.meanCellHeight

arr = arcpy.RasterToNumPyArray(fill_raster, nodata_to_value=np.nan)
cell_area = csx * csy

positive = arr.copy()
positive[positive <= 0] = np.nan

volume_m3 = float(np.nansum(positive) * cell_area)

# Footprint area considered (cells with non-nan in post_idw)
post_arr = arcpy.RasterToNumPyArray(post_idw, nodata_to_value=np.nan)
valid_mask = ~np.isnan(post_arr)
area_m2 = float(np.sum(valid_mask) * cell_area)

print("RESULT_VOLUME_M3:", volume_m3)
print("RESULT_AREA_M2:", area_m2)

