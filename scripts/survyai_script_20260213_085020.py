# Generated by SurvyAI
# This script was dynamically generated based on user request
# Generated: 2026-02-13T08:50:20.024968
# 
# Execute this script in ArcGIS Pro's Python Window if needed:
# exec(open(r'C:\Users\UZOR\PycharmProjects\untitled\venv\SurvyAI\scripts\survyai_script_20260213_085020.py').read())

import arcpy, os

# Input parameters
excel_path = r'C:\Users\UZOR\PycharmProjects\untitled\venv\SurvyAI\WELL 8 TOPO DATA.xlsx'
base_folder = os.path.dirname(excel_path)
project_name = 'WELL8_Fill_Volume'
project_folder = base_folder
aprx_path = os.path.join(project_folder, project_name + '.aprx')

# Create a new file geodatabase for this analysis
gdb_path = os.path.join(project_folder, 'WELL8_Fill_Volume.gdb')
if not arcpy.Exists(gdb_path):
    arcpy.management.CreateFileGDB(project_folder, 'WELL8_Fill_Volume')

arcpy.env.workspace = gdb_path
arcpy.env.overwriteOutput = True

# Nigerian Mid-Belt Projection (Minna / Nigeria Mid Belt, EPSG:26392)
sr = arcpy.SpatialReference(26392)

# Step 1: Convert Excel sheets to tables
excel_table_prefill = os.path.join(gdb_path, 'PreFill_tbl')
excel_table_postfill = os.path.join(gdb_path, 'PostFill_tbl')

if not arcpy.Exists(excel_table_prefill):
    arcpy.conversion.ExcelToTable(excel_path, excel_table_prefill, 'Pre-fill')
if not arcpy.Exists(excel_table_postfill):
    arcpy.conversion.ExcelToTable(excel_path, excel_table_postfill, 'Post-fill')

# Helper: find X/Y/Z fields heuristically
def detect_xyz_fields(table):
    fields = [f.name for f in arcpy.ListFields(table)]
    lower = [f.lower() for f in fields]
    def pick(candidates):
        for cand in candidates:
            if cand in lower:
                return fields[lower.index(cand)]
        return None
    x_field = pick(['x', 'easting', 'east', 'lon', 'longitude'])
    y_field = pick(['y', 'northing', 'north', 'lat', 'latitude'])
    z_field = pick(['z', 'elev', 'elevation', 'height', 'rl'])
    return x_field, y_field, z_field

x_pre, y_pre, z_pre = detect_xyz_fields(excel_table_prefill)
x_post, y_post, z_post = detect_xyz_fields(excel_table_postfill)

if not all([x_pre, y_pre, z_pre, x_post, y_post, z_post]):
    raise RuntimeError('Could not auto-detect X/Y/Z fields for one or both sheets. Check field names in Excel.')

# Step 2: Create point feature classes from the tables (explicit float casting to avoid text issues)

def table_to_points(table, fc_name, x_field, y_field):
    fc = os.path.join(gdb_path, fc_name)
    if arcpy.Exists(fc):
        arcpy.management.Delete(fc)
    arcpy.management.CreateFeatureclass(gdb_path, fc_name, 'POINT', spatial_reference=sr)
    arcpy.management.AddField(fc, 'SrcOID', 'LONG')
    with arcpy.da.SearchCursor(table, ['OID@', x_field, y_field]) as sc, \
         arcpy.da.InsertCursor(fc, ['SrcOID', 'SHAPE@XY']) as ic:
        for oid, x_raw, y_raw in sc:
            if x_raw is None or y_raw is None:
                continue
            try:
                x = float(str(x_raw).replace(',', ''))
                y = float(str(y_raw).replace(',', ''))
            except Exception:
                continue
            ic.insertRow((oid, (x, y)))
    return fc

prefill_points = table_to_points(excel_table_prefill, 'PreFill_pts', x_pre, y_pre)
postfill_points = table_to_points(excel_table_postfill, 'PostFill_pts', x_post, y_post)

# Step 3: Add Z attributes to point feature classes by joining back to tables

def add_z_field(points_fc, table, z_field, out_z_field):
    if out_z_field not in [f.name for f in arcpy.ListFields(points_fc)]:
        arcpy.management.AddField(points_fc, out_z_field, 'DOUBLE')
    arcpy.management.JoinField(points_fc, 'SrcOID', table, 'OBJECTID', [z_field])
    with arcpy.da.UpdateCursor(points_fc, [out_z_field, z_field]) as uc:
        for z_out, z_in in uc:
            if z_in is None:
                uc.updateRow((None, z_in))
            else:
                try:
                    z_val = float(str(z_in).replace(',', ''))
                except Exception:
                    z_val = None
                uc.updateRow((z_val, z_in))
    # Remove the original joined Z field to keep schema clean
    arcpy.management.RemoveJoin(points_fc)

add_z_field(prefill_points, excel_table_prefill, z_pre, 'Z_PREF')
add_z_field(postfill_points, excel_table_postfill, z_post, 'Z_POST')

# Step 4: Create TINs from the point feature classes using Z fields

prefill_tin = os.path.join(project_folder, 'PreFill_TIN')
postfill_tin = os.path.join(project_folder, 'PostFill_TIN')

if arcpy.Exists(prefill_tin):
    arcpy.management.Delete(prefill_tin)
if arcpy.Exists(postfill_tin):
    arcpy.management.Delete(postfill_tin)

arcpy.ddd.CreateTin(prefill_tin, sr, [[prefill_points, 'Z_PREF', 'Mass_Points']], 'DELAUNAY')
arcpy.ddd.CreateTin(postfill_tin, sr, [[postfill_points, 'Z_POST', 'Mass_Points']], 'DELAUNAY')

# Step 5: Convert TINs to rasters (IDW-like surfaces via interpolation from points is mimicked by TIN->Raster)

prefill_raster = os.path.join(gdb_path, 'PreFill_Ras')
postfill_raster = os.path.join(gdb_path, 'PostFill_Ras')

cell_size = None  # Let ArcGIS choose; or set numeric value in map units

arcpy.ddd.TinRaster(prefill_tin, prefill_raster, 'FLOAT', 'LINEAR', 'CELLSIZE', cell_size)
arcpy.ddd.TinRaster(postfill_tin, postfill_raster, 'FLOAT', 'LINEAR', 'CELLSIZE', cell_size)

# Step 6: Create polygon of Post-fill extent ONLY and use as mask

# Convert Post-fill points to convex hull polygon (area strictly covered by Post-fill data)
postfill_hull = os.path.join(gdb_path, 'PostFill_Hull')
if arcpy.Exists(postfill_hull):
    arcpy.management.Delete(postfill_hull)

arcpy.management.MinimumBoundingGeometry(postfill_points, postfill_hull, 'CONVEX_HULL', group_option='ALL')

# Use hull as processing mask
arcpy.env.mask = postfill_hull

# Step 7: Perform Cut/Fill analysis (Post - Pre) within Post-fill area only

cutfill_raster = os.path.join(gdb_path, 'CutFill_Ras')
if arcpy.Exists(cutfill_raster):
    arcpy.management.Delete(cutfill_raster)

arcpy.ddd.CutFill(postfill_raster, prefill_raster, cutfill_raster)

# Step 8: Summarize fill volume (positive change) in cubic meters

# Create a raster attribute table if needed
try:
    arcpy.management.BuildRasterAttributeTable(cutfill_raster, 'OVERWRITE')
except Exception:
    pass

fill_volume = 0.0
cell_area = None

# Use Raster to NumPy array to compute directly
from arcpy.sa import Raster
import numpy as np

r = Raster(cutfill_raster)
arr = arcpy.RasterToNumPyArray(r, nodata_to_value=np.nan)

# Cell size in meters (since CRS is metric)
cs_x = r.meanCellWidth
cs_y = r.meanCellHeight
cell_area = cs_x * cs_y

# Positive differences = fill
valid = arr[~np.isnan(arr)]
fill_cells = valid[valid > 0]
fill_volume = float(fill_cells.sum() * cell_area)

print('RESULT_FILL_VOLUME_CUBIC_METERS:', fill_volume)
print('RESULT_CELL_SIZE_X_M:', cs_x)
print('RESULT_CELL_SIZE_Y_M:', cs_y)
print('RESULT_CELL_AREA_SQ_M:', cell_area)

# Step 9: Export summary to Excel in same folder as input

results_excel = os.path.join(base_folder, 'results_fill.xlsx')

# Create a temporary CSV first
csv_path = os.path.join(base_folder, 'results_fill_temp.csv')
with open(csv_path, 'w') as f:
    f.write('Metric,Value\n')
    f.write('FillVolume_m3,{}\n'.format(fill_volume))
    f.write('CellSizeX_m,{}\n'.format(cs_x))
    f.write('CellSizeY_m,{}\n'.format(cs_y))
    f.write('CellArea_m2,{}\n'.format(cell_area))

# Convert CSV to Excel using arcpy.TableToExcel
if arcpy.Exists(results_excel):
    arcpy.management.Delete(results_excel)

arcpy.conversion.TableToExcel(csv_path, results_excel)

print('RESULT_EXCEL_PATH:', results_excel)

