# Generated by SurvyAI
# This script was dynamically generated based on user request
# Generated: 2026-01-05T12:17:10.696027
# 
# Execute this script in ArcGIS Pro's Python Window if needed:
# exec(open(r'C:\Users\UZOR\PycharmProjects\untitled\venv\SurvyAI\scripts\pullman_eleme_traverse.py').read())

import arcpy, os, math, csv

# Input paths
folder = r"C:\Users\UZOR\PycharmProjects\untitled\venv\SurvyAI"
excel_path = os.path.join(folder, "converted3.xlsx")
result_excel = os.path.join(folder, "result1.xlsx")

# Create a new file geodatabase and feature classes inside a scratch workspace
arcpy.env.overwriteOutput = True

# Create a temporary GDB in the same folder
gdb_path = os.path.join(folder, "PullmanElemeTest.gdb")
if not arcpy.Exists(gdb_path):
    arcpy.management.CreateFileGDB(folder, "PullmanElemeTest.gdb")

# Define spatial reference for Minna / Nigeria Mid Belt (EPSG: 26392)
sr = arcpy.SpatialReference(26392)

# Convert Excel to table
excel_table = os.path.join(gdb_path, "points_table")
if arcpy.Exists(excel_table):
    arcpy.management.Delete(excel_table)

arcpy.conversion.ExcelToTable(excel_path, excel_table)

# Discover X/Y fields (look for 'Long' and 'Lat' or 'Easting'/'Northing')
fields = [f.name for f in arcpy.ListFields(excel_table)]

x_candidates = [f for f in fields if 'Long' in f or 'Easting' in f or 'X' == f]
y_candidates = [f for f in fields if 'Lat' in f or 'North' in f or 'Y' == f]

if not x_candidates or not y_candidates:
    raise Exception("Could not find coordinate fields in converted3.xlsx. Fields found: {}".format(fields))

x_field = x_candidates[0]
y_field = y_candidates[0]

# Create point feature class
points_fc = os.path.join(gdb_path, "points")
if arcpy.Exists(points_fc):
    arcpy.management.Delete(points_fc)

arcpy.management.CreateFeatureclass(gdb_path, "points", "POINT", spatial_reference=sr)

# Add source OID field for reference
arcpy.management.AddField(points_fc, "SrcOID", "LONG")

# Insert points with proper numeric casting
with arcpy.da.SearchCursor(excel_table, ["OID@", x_field, y_field]) as sc:
    with arcpy.da.InsertCursor(points_fc, ["SrcOID", "SHAPE@XY"]) as ic:
        for oid, x_raw, y_raw in sc:
            try:
                x = float(str(x_raw).replace(",", "").strip())
                y = float(str(y_raw).replace(",", "").strip())
            except:
                continue
            ic.insertRow((oid, (x, y)))

# Create convex hull polygon (tight fitting polygon around all points)
polygon_fc = os.path.join(gdb_path, "points_hull")
if arcpy.Exists(polygon_fc):
    arcpy.management.Delete(polygon_fc)

arcpy.management.MinimumBoundingGeometry(points_fc, polygon_fc, "CONVEX_HULL", group_option="ALL")

# Calculate area of polygon in square meters
area_m2 = None
with arcpy.da.SearchCursor(polygon_fc, ["SHAPE@"]) as cursor:
    for row in cursor:
        geom = row[0]
        area_m2 = geom.area
        break

# Get ordered points (by SrcOID) as a traverse and compute distances & bearings
points = []
with arcpy.da.SearchCursor(points_fc, ["SrcOID", "SHAPE@XY"], sql_clause=(None, "ORDER BY SrcOID")) as cursor:
    for oid, (x, y) in cursor:
        points.append((oid, x, y))

# If polygon should be closed, include leg from last back to first
results = []
for i in range(len(points)):
    oid1, x1, y1 = points[i]
    oid2, x2, y2 = points[(i + 1) % len(points)]  # wrap around
    dx = x2 - x1
    dy = y2 - y1
    distance = math.sqrt(dx*dx + dy*dy)
    # Bearing from north, clockwise (0-360 degrees)
    # arctan2(dx, dy) because dx is east, dy is north
    bearing_rad = math.atan2(dx, dy)
    bearing_deg = math.degrees(bearing_rad)
    if bearing_deg < 0:
        bearing_deg += 360.0
    results.append({
        "From_OID": oid1,
        "To_OID": oid2,
        "Distance_m": distance,
        "Bearing_deg": bearing_deg
    })

# Print results for parsing
print("RESULT_AREA_SQM:", area_m2)

for r in results:
    print("RESULT_TRAVERSE_LEG:", r["From_OID"], r["To_OID"], r["Distance_m"], r["Bearing_deg"])

# Save results to CSV (Excel-readable)
with open(result_excel, 'w', newline='') as csvfile:
    writer = csv.writer(csvfile)
    writer.writerow(["From_OID", "To_OID", "Distance_m", "Bearing_deg", "Area_sqm"])
    for r in results:
        writer.writerow([r["From_OID"], r["To_OID"], r["Distance_m"], r["Bearing_deg"], area_m2])

