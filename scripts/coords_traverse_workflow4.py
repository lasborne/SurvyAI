# Generated by SurvyAI
# This script was dynamically generated based on user request
# Generated: 2026-02-08T10:30:21.939456
# 
# Execute this script in ArcGIS Pro's Python Window if needed:
# exec(open(r'C:\Users\UZOR\PycharmProjects\untitled\venv\SurvyAI\scripts\coords_traverse_workflow4.py').read())

import arcpy, os, csv, math

# Paths
csv_path = r'C:\Users\UZOR\PycharmProjects\untitled\venv\SurvyAI\Coords.csv'
base_folder = os.path.dirname(csv_path)
coords_xlsx = os.path.join(base_folder, 'Coords.xlsx')
converted_xlsx = os.path.join(base_folder, 'converted4.xlsx')
result_xlsx = os.path.join(base_folder, 'result4.xlsx')
project_name = 'Coords_Project4'
project_folder = base_folder
aprx_path = os.path.join(project_folder, project_name + '.aprx')

# 1) Create a simple .xlsx from the CSV using Python's csv and arcpy.Excel tools
#    We'll write to a temporary CSV then use ExcelToTable if needed; but simplest is to copy structure.

# Ensure workspace
arcpy.env.overwriteOutput = True

# Read CSV and write a clean CSV (to ensure delimiter correctness)
clean_csv = os.path.join(base_folder, 'Coords_clean_for_excel4.csv')
with open(csv_path, 'r', newline='') as src, open(clean_csv, 'w', newline='') as dst:
    reader = csv.reader(src)
    writer = csv.writer(dst)
    for row in reader:
        writer.writerow(row)

# Use Excel conversion via arcpy.conversion.TableToExcel
coords_table = os.path.join('in_memory', 'coords_tbl4')
arcpy.management.Delete('in_memory')
arcpy.management.CreateTable('in_memory', 'coords_tbl4')

# Dynamically add fields by reading header from clean_csv
with open(clean_csv, 'r', newline='') as f:
    reader = csv.reader(f)
    header = next(reader)

# Map first two numeric-like columns as X (Easting) and Y (Northing) if names not standard
# but we still copy all columns
fields_info = []
for h in header:
    name = h.strip().replace(' ', '_')
    if not name:
        name = 'Field_' + str(len(fields_info)+1)
    # Limit field name length for geodatabase tables
    if len(name) > 30:
        name = name[:30]
    # Default to DOUBLE for safety (numeric coords)
    arcpy.management.AddField(coords_table, name, 'DOUBLE', field_length=50)
    fields_info.append(name)

# Insert rows, attempting numeric cast
with arcpy.da.InsertCursor(coords_table, fields_info) as ic:
    with open(clean_csv, 'r', newline='') as f:
        reader = csv.reader(f)
        next(reader)  # skip header
        for row in reader:
            values = []
            for v in row:
                v = v.strip()
                if v == '':
                    values.append(None)
                else:
                    try:
                        values.append(float(v))
                    except:
                        # if non-numeric, store NULL because fields are DOUBLE
                        values.append(None)
            # pad/truncate
            if len(values) < len(fields_info):
                values += [None] * (len(fields_info) - len(values))
            elif len(values) > len(fields_info):
                values = values[:len(fields_info)]
            ic.insertRow(values)

# Export to Excel as Coords.xlsx
arcpy.conversion.TableToExcel(coords_table, coords_xlsx)

# Discover X/Y fields: prefer names containing 'x', 'e', 'east' and 'y', 'n', 'north'
fields = [f.name for f in arcpy.ListFields(coords_table)]

x_candidates = [f for f in fields if f.lower() in ('x', 'easting', 'east') or 'east' in f.lower() or f.lower().startswith('e')]
y_candidates = [f for f in fields if f.lower() in ('y', 'northing', 'north') or 'north' in f.lower() or f.lower().startswith('n')]

if not x_candidates or not y_candidates:
    raise RuntimeError('Could not identify X/Y fields in Coords.csv. Please ensure it has recognizable Easting/Northing columns.')

x_field = x_candidates[0]
y_field = y_candidates[0]

# 2) Convert UTM Zone 32N (EPSG:32632) to WGS84 (EPSG:4326) and write converted4.xlsx

# Create output table for converted coordinates
converted_table = os.path.join('in_memory', 'converted_tbl4')
arcpy.management.CreateTable('in_memory', 'converted_tbl4')

# Copy existing fields
for f_name in fields:
    arcpy.management.AddField(converted_table, f_name, 'DOUBLE')

# Add new fields for converted Lon/Lat
arcpy.management.AddField(converted_table, 'Lon_WGS84', 'DOUBLE')
arcpy.management.AddField(converted_table, 'Lat_WGS84', 'DOUBLE')

# Define spatial references
utm32n = arcpy.SpatialReference(32632)  # WGS 84 / UTM zone 32N
wgs84 = arcpy.SpatialReference(4326)    # WGS 84 geographic

# Project each point
with arcpy.da.SearchCursor(coords_table, fields + [x_field, y_field]) as sc, \
     arcpy.da.InsertCursor(converted_table, fields + ['Lon_WGS84', 'Lat_WGS84']) as ic:
    for row in sc:
        row_dict = dict(zip(fields + [x_field, y_field], row))
        x = row_dict[x_field]
        y = row_dict[y_field]
        if x is None or y is None:
            continue
        pt = arcpy.Point(float(x), float(y))
        geom = arcpy.PointGeometry(pt, utm32n)
        proj_geom = geom.projectAs(wgs84)
        lon = proj_geom.firstPoint.X
        lat = proj_geom.firstPoint.Y
        base_vals = [row_dict[f] for f in fields]
        ic.insertRow(base_vals + [lon, lat])

# Export converted table to converted4.xlsx
arcpy.conversion.TableToExcel(converted_table, converted_xlsx)

# 3) Use converted WGS84 coordinates to build closed traverse, compute area and bearings/distances

# Create a new project if it does not exist
if not os.path.exists(aprx_path):
    # Create a basic project (map template)
    aprx = arcpy.mp.ArcGISProject('C:/Program Files/ArcGIS/Pro/Resources/Template/Map/Blank.aprx')
    aprx.saveACopy(aprx_path)

aprx = arcpy.mp.ArcGISProject(aprx_path)

# Prepare a file geodatabase
gdb_path = os.path.join(project_folder, project_name + '.gdb')
if not arcpy.Exists(gdb_path):
    arcpy.management.CreateFileGDB(project_folder, project_name + '.gdb')

arcpy.env.workspace = gdb_path

# Import converted_xlsx as a table
excel_table = arcpy.conversion.ExcelToTable(converted_xlsx, os.path.join(gdb_path, 'converted_tbl4_excel'))

# Discover Lon/Lat fields
excel_fields = [f.name for f in arcpy.ListFields(excel_table)]
lon_field = 'Lon_WGS84'
lat_field = 'Lat_WGS84'
if lon_field not in excel_fields or lat_field not in excel_fields:
    raise RuntimeError('Converted Excel does not contain Lon_WGS84/Lat_WGS84 fields.')

# Create point feature class in WGS84
points_fc = os.path.join(gdb_path, 'TraversePoints4')
if arcpy.Exists(points_fc):
    arcpy.management.Delete(points_fc)

arcpy.management.CreateFeatureclass(gdb_path, 'TraversePoints4', 'POINT', spatial_reference=wgs84)
arcpy.management.AddField(points_fc, 'PtID', 'LONG')

# Insert points in order of OID
with arcpy.da.SearchCursor(excel_table, ['OID@', lon_field, lat_field]) as sc, \
     arcpy.da.InsertCursor(points_fc, ['PtID', 'SHAPE@XY']) as ic:
    for oid, lon, lat in sc:
        if lon is None or lat is None:
            continue
        ic.insertRow((oid, (float(lon), float(lat))))

# Create a polyline traverse (closed)
lines_fc = os.path.join(gdb_path, 'TraverseLines4')
if arcpy.Exists(lines_fc):
    arcpy.management.Delete(lines_fc)

# Read all points ordered by PtID
pts = []
with arcpy.da.SearchCursor(points_fc, ['PtID', 'SHAPE@XY'], sql_clause=(None, 'ORDER BY PtID')) as sc:
    for pid, (x, y) in sc:
        pts.append((x, y))

if len(pts) < 3:
    raise RuntimeError('Not enough points to create a closed traverse (minimum 3).')

# Close traverse by repeating first point at end
if pts[0] != pts[-1]:
    pts.append(pts[0])

array = arcpy.Array([arcpy.Point(x, y) for x, y in pts])
polyline = arcpy.Polyline(array, wgs84)

arcpy.management.CreateFeatureclass(gdb_path, 'TraverseLines4', 'POLYLINE', spatial_reference=wgs84)
with arcpy.da.InsertCursor(lines_fc, ['SHAPE@']) as ic:
    ic.insertRow([polyline])

# Create polygon from polyline (for area)
polygon_fc = os.path.join(gdb_path, 'TraversePolygon4')
if arcpy.Exists(polygon_fc):
    arcpy.management.Delete(polygon_fc)

arcpy.management.FeatureToPolygon(lines_fc, polygon_fc)

# Compute area in square meters and hectares (geodesic via projection to UTM 32N)
projected_polygon_fc = os.path.join(gdb_path, 'TraversePolygon4_UTM32')
if arcpy.Exists(projected_polygon_fc):
    arcpy.management.Delete(projected_polygon_fc)

arcpy.management.Project(polygon_fc, projected_polygon_fc, utm32n)

area_sqm = 0.0
with arcpy.da.SearchCursor(projected_polygon_fc, ['SHAPE@AREA']) as sc:
    for (geom,) in sc:
        area_sqm += geom

area_hectares = area_sqm / 10000.0

print('RESULT_AREA_SQM:', area_sqm)
print('RESULT_AREA_HECTARES:', area_hectares)

# Compute bearings and distances between consecutive vertices in UTM32N (metric)

# Project points to UTM 32N for metric distances
points_utm_fc = os.path.join(gdb_path, 'TraversePoints4_UTM32')
if arcpy.Exists(points_utm_fc):
    arcpy.management.Delete(points_utm_fc)

arcpy.management.Project(points_fc, points_utm_fc, utm32n)

# Read ordered UTM points
utm_pts = []
with arcpy.da.SearchCursor(points_utm_fc, ['PtID', 'SHAPE@XY'], sql_clause=(None, 'ORDER BY PtID')) as sc:
    for pid, (x, y) in sc:
        utm_pts.append((pid, x, y))

# Ensure closed order
if len(utm_pts) < 3:
    raise RuntimeError('Not enough projected points to compute traverse.')

rows = []
for i in range(len(utm_pts)):
    pid1, x1, y1 = utm_pts[i]
    pid2, x2, y2 = utm_pts[(i+1) % len(utm_pts)]  # wrap around to close
    dx = x2 - x1
    dy = y2 - y1
    distance = math.hypot(dx, dy)
    # Bearing from north, clockwise, in degrees
    bearing_rad = math.atan2(dx, dy)
    bearing_deg = (math.degrees(bearing_rad) + 360) % 360
    rows.append((pid1, pid2, distance, bearing_deg))
    print(f'RESULT_SEGMENT_P{pid1}_P{pid2}_DIST_M:', distance)
    print(f'RESULT_SEGMENT_P{pid1}_P{pid2}_BEARING_DEG:', bearing_deg)

# Write result4.xlsx as an Excel table via a temp table
result_table = os.path.join('in_memory', 'TraverseResults4')
if arcpy.Exists(result_table):
    arcpy.management.Delete(result_table)

arcpy.management.CreateTable('in_memory', 'TraverseResults4')
arcpy.management.AddField(result_table, 'FromPt', 'LONG')
arcpy.management.AddField(result_table, 'ToPt', 'LONG')
arcpy.management.AddField(result_table, 'Distance_m', 'DOUBLE')
arcpy.management.AddField(result_table, 'Bearing_deg', 'DOUBLE')

with arcpy.da.InsertCursor(result_table, ['FromPt', 'ToPt', 'Distance_m', 'Bearing_deg']) as ic:
    for r in rows:
        ic.insertRow(r)

arcpy.conversion.TableToExcel(result_table, result_xlsx)

# Symbolize traverse line in red in the map
maps = aprx.listMaps()
if maps:
    m = maps[0]
    # Add layers if not already present
    if not any(lyr.name == 'TraverseLines4' for lyr in m.listLayers()):
        m.addDataFromPath(lines_fc)
    if not any(lyr.name == 'TraversePoints4' for lyr in m.listLayers()):
        m.addDataFromPath(points_fc)
    # Try to set line symbol to red
    for lyr in m.listLayers():
        if lyr.name == 'TraverseLines4' and hasattr(lyr, 'symbology'):
            sym = lyr.symbology
            if hasattr(sym, 'renderer'):
                try:
                    sym.renderer.symbol.color = {'RGB': [255, 0, 0, 100]}
                    lyr.symbology = sym
                except:
                    pass

    # Optional: set extent to points
    try:
        ext = arcpy.Describe(points_fc).extent
        if hasattr(m, 'defaultCamera'):
            m.defaultCamera.setExtent(ext)
    except:
        pass

aprx.save()

